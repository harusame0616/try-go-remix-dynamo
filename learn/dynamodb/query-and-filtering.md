# DynamoDB のクエリとフィルタリング

## ソートキーでの範囲クエリ

ソートキーに対しては比較演算子が使える。

```
# 特定のセンサーの 2026年1月のデータだけ取得
PK = "sensor#001"
SK BETWEEN "2026-01-01T00:00:00Z" AND "2026-01-31T23:59:59Z"
```

### 使える演算子

| 演算子 | 用途 |
|---|---|
| `=` | 完全一致 |
| `<`, `<=`, `>`, `>=` | 比較 |
| `BETWEEN ... AND ...` | 範囲指定 |
| `begins_with()` | 前方一致（例: `begins_with(SK, "2026-01")` で2026年1月分） |

### ソート順

`ScanIndexForward=false` を指定すれば降順で取得可能。デフォルトは昇順。

## 属性でのフィルタリング（FilterExpression）

キー以外の属性でフィルタするには **FilterExpression** を使う。

```
PK = "sensor#001"
FilterExpression: temperature > 30
```

### 重要な注意点

FilterExpression は**読み取り後にフィルタする**仕組み。

1. DynamoDB がまず PK + SK 条件でアイテムを読み取る（ここで課金される）
2. その後 FilterExpression で絞り込む
3. 条件に合わないアイテムは返さないが、**読み取りコストは発生済み**

```
[ 1000件読み取り ] → [ FilterExpression ] → [ 3件だけ返却 ]
         ↑                                        ↑
    1000件分課金される              ユーザーには3件しか届かない
```

RDB の WHERE 句とは根本的に異なり、FilterExpression は**ただの後処理フィルタ**。

## 属性で効率的にクエリする方法：GSI

**GSI（グローバルセカンダリインデックス）** を作成することで、キー以外の属性でも効率的にクエリできる。

例：「温度が異常値のセンサーデータを効率的に取りたい」

```
GSI:
  PK: sensor_id
  SK: temperature
```

これで `temperature > 30` のクエリがインデックスを使って効率的に実行できる。

## まとめ

| やりたいこと | 方法 | 効率 |
|---|---|---|
| SK の範囲指定 | Query の KeyConditionExpression | 高い（必要なデータだけ読む） |
| SK の降順取得 | `ScanIndexForward=false` | 高い |
| 属性での絞り込み | FilterExpression | **低い**（全部読んでからフィルタ） |
| 属性での効率的な絞り込み | GSI を作成 | 高い（追加コストあり） |

**設計原則**: 「キー（PK + SK）でのクエリは効率的、それ以外は後処理かインデックス追加」。だからこそアクセスパターンを先に洗い出してキーと GSI を設計することが重要。
