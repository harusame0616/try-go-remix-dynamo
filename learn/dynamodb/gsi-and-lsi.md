# DynamoDB の GSI と LSI（セカンダリインデックス）

- **GSI** = Global Secondary Index（グローバルセカンダリインデックス）
- **LSI** = Local Secondary Index（ローカルセカンダリインデックス）
- どちらも「**セカンダリインデックス（Secondary Index）**」= 主キー以外でクエリするための補助的なインデックス

## Global / Local の名前の由来

パーティション（PK）を跨ぐかどうかで名前が決まっている。

```
テーブル全体
┌──────────────────────────────────────────┐
│  パーティション A        パーティション B       │
│  (PK=sensor#001)     (PK=sensor#002)    │
│  ┌──────────┐        ┌──────────┐       │
│  │ item 1   │        │ item 3   │       │
│  │ item 2   │        │ item 4   │       │
│  └──────────┘        └──────────┘       │
│                                          │
│  LSI → パーティション内だけ（Local）         │
│  GSI → パーティションを跨いで全体（Global）   │
└──────────────────────────────────────────┘
```

- **LSI（Local）**: 同じ PK のパーティション内で、別の SK でソート・クエリしたいとき
- **GSI（Global）**: PK 自体を変えて、テーブル全体を横断してクエリしたいとき

## 具体例

元テーブル: PK=sensor_id, SK=timestamp

### LSI のユースケース

「同じセンサー内で、温度順に並べたい」

- LSI: PK: sensor_id（元テーブルと同じ）, SK: temperature
- → sensor#001 の中で温度が高い順にデータを取れる

### GSI のユースケース

「場所（location）別に、全センサーのデータを横断して取りたい」

- GSI: PK: location, SK: timestamp
- → location=東京 の全センサーデータを時系列で取れる

## GSI のコスト

GSI は**独立したストレージとスループットを消費する**。

### 仕組み

GSI を作ると、DynamoDB は元テーブルから GSI 用のデータを複製して別の場所に保持する。

```
元テーブル                          GSI
┌─────────────────────┐        ┌─────────────────────┐
│ PK: sensor#001      │   複製  │ PK: sensor#001      │
│ SK: 2026-01-01T...  │ ─────→ │ SK: 35.2 (温度)     │
│ temperature: 35.2   │        │ timestamp: 2026-... │
└─────────────────────┘        └─────────────────────┘
```

### コストの内訳

- **ストレージ**: 元データ + GSI 分のデータで二重に課金
- **書き込み**: 元テーブルに書き込むと GSI にも自動で反映される → 書き込みコストも増える
- **読み取り**: GSI 経由のクエリは GSI 自体のキャパシティを消費

GSI を3つ作れば、書き込み時に最大4回（元テーブル + GSI×3）の書き込みが発生しうる。

## 設定上の制約

後から追加すること自体は簡単。AWS コンソールや API から追加できる。

| 制約 | 内容 |
|---|---|
| 数の上限 | 1テーブルあたり GSI は最大20個（デフォルト） |
| 作成時間 | 既存データが多いとバックフィル（既存データの複製）に時間がかかる |
| キー変更不可 | 一度作った GSI のキー定義は変更できない。変更したければ削除して再作成 |

## GSI vs LSI の比較

| | GSI（グローバル） | LSI（ローカル） |
|---|---|---|
| 名前の由来 | テーブル全体を横断（Global） | パーティション内に限定（Local） |
| PK | 元テーブルと別の PK を指定可能 | 元テーブルと同じ PK |
| SK | 自由に指定 | 自由に指定 |
| 後から追加 | 可能 | **不可（テーブル作成時のみ）** |
| サイズ制限 | なし | 同一 PK あたり 10GB |
| ストレージ | 独立（データ複製） | 元テーブルと共有 |
| 整合性 | 結果整合性のみ | 強い整合性も選択可能 |

LSI は後から追加できないため、テーブル設計時に慎重に検討する必要がある。

## 実務的な使い分け

- **GSI だけで大抵のケースはカバーできる**
- LSI は「後から追加不可」という制約がきつい
- AWS の公式ドキュメントでも「迷ったら GSI を使え」というスタンス
- LSI を選ぶ明確な理由があるケース：
  - 強い整合性が必要
  - 元テーブルと同じ PK でソートだけ変えたい

## まとめ

- 金銭的コストは「データ複製 + 書き込み増加」による追加料金
- 後から追加するのは簡単だが、むやみに増やすと書き込みコストが膨れる
- 本当に必要なアクセスパターンを見極めてから GSI を作ることが重要
- 迷ったら GSI を選択し、LSI は強い整合性が必要な場合など明確な理由があるときだけ使う
