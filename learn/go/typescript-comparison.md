# TypeScript と Go の比較

## 言語特性の違い

| | TypeScript (Node.js) | Go |
|---|---|---|
| 型システム | 構造的型付け、型推論が強力 | 静的型付け、シンプル |
| 並行処理 | シングルスレッド + イベントループ | goroutine（軽量スレッド） |
| エラー処理 | try/catch（例外） | 戻り値で返す（error 型） |
| null 安全性 | strictNullChecks で対応 | ゼロ値 + ポインタの nil |
| パッケージ管理 | npm（巨大エコシステム） | go modules（標準） |
| ビルド成果物 | JS ファイル（ランタイム必要） | 単一バイナリ（ランタイム不要） |
| 起動速度 | 遅め（V8 の JIT） | 速い（ネイティブバイナリ） |
| メモリ使用量 | 多め | 少ない |
| ジェネリクス | 最初からある | Go 1.18 で追加（制限あり） |
| 継承 | クラスベース + プロトタイプ | なし（埋め込み + インターフェース） |

## サーバーサイドでの比較

### TypeScript (Node.js) が向いている場面

- I/O バウンドな Web アプリケーション
- REST API / GraphQL サーバー、BFF
- フロントエンドと型を共有したい場合
- プロトタイピング、MVP の高速開発
- npm の豊富なライブラリを活用したい場合

#### メリット

- フロントエンドと言語統一できる（採用・学習コスト減）
- エコシステムが圧倒的に大きい
- 開発速度が速い（動的言語的な柔軟さ + 型安全性）
- JSON との相性が抜群

#### デメリット

- CPU バウンドな処理に弱い（シングルスレッド）
- メモリ消費が大きい
- node_modules の依存地獄
- ランタイムエラーが型チェックをすり抜けることがある（any、型アサーション）

### Go が向いている場面

- 高スループット・低レイテンシが求められるシステム
- マイクロサービス
- API ゲートウェイ / プロキシ
- CLI ツール
- IoT のデータ収集基盤
- インフラツール（Docker, Kubernetes, Terraform は全部 Go）

#### メリット

- 並行処理が簡単で強力（goroutine + channel）
- コンパイルが速い、実行も速い
- メモリ効率が良い（Node.js の 1/5〜1/10 程度）
- デプロイが楽（単一バイナリ、Docker イメージも小さい）
- 言語仕様がシンプルで、誰が書いても似たコードになる

#### デメリット

- エラー処理が冗長（if err != nil の繰り返し）
- ジェネリクスが制限的（TS ほど自由に型を操れない）
- npm ほどのエコシステムはない
- JSON のハンドリングが面倒（構造体にマッピングが必要）
- 言語仕様のシンプルさが裏目に出ることがある（表現力の低さ）

## どちらを選ぶべきか

### 状況別の選択指針

| 状況 | 選択 |
|------|------|
| フロントエンドチームがバックエンドも書く | TypeScript |
| フロントとバックで型共有したい | TypeScript |
| とにかく早くリリースしたい | TypeScript |
| 大量の同時接続を捌く必要がある | Go |
| マイクロサービスを大量に作る | Go |
| インフラ/DevOps 系のツール | Go |
| IoT でセンサーデータを大量に受ける | Go |
| チームに Go 経験者がいない | TypeScript（学習コストを考慮） |

### 実務での考え方

チームの状況で決めるのが現実的。技術的優劣だけで選ぶべきではない。どちらも十分にサーバーサイドで実績がある。言語選択で致命的な失敗をすることは稀で、問題になるのはたいてい設計やアーキテクチャの方。
